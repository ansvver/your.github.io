---
layout: post
title: "由“三堆游戏”说起"
description: "Nim游戏是博弈论中最经典的模型，它又有着十分简单的规则和无比优美的结论."
keywords: "math, algorithm, funny, game"
category: 数学奥义
tags: [Math, Algorithm, Fun, Game]
---
{% include JB/setup %}

我们的高级人工智能是一个老教授，但却算是和我们比较closed的老师了（无奈- -）。他很风趣，也很关心和看重年轻人。有一天课间，他见课室里很多人都无精打彩的（下午这门课连上四节- -），于是就说跟我们玩一个游戏吧，这样大家可以精神点。于是，他拿起一根粉笔，在黑板上随意地画出了三堆小圆圈，每一堆的数量都是随机的（他随手画出的），说，

<!-- more -->

> 同学们，现在这里有三堆小圏圈，每堆的数量是任意的，游戏规则很简单，就是二人轮流在其中一堆中拿去其中的小圈圈，每次至少拿一个，当然最多就一次把一堆全拿光了。拿到最后的那个圈圈的人就输了。

其实这是一个Nim游戏，是博弈论中的经典模型，它又有着十分简单的规则以及无比优美的结论。通常的Nim游戏的定义是这样的：有若干堆石子，每堆石子的数量都是有限的，合法的移动是“选择一堆石子并拿走若干颗（不能不拿）”，如果轮到某个人时所有的石子堆都已经被拿空了，则判负（因为他此刻没有任何合法的移动）。上面游戏实质上就是一个三堆石子游戏。

###思路

对于这样的一个三堆石子游戏，这里用`(a, b, c)`这个三元组来表示分别三堆石子当前的数量。为了方便叙述，以下的“取子玩家”指的是“当前取子的玩家”，另外以下情况均以双方了解游戏的取胜策略为前提。先来考虑简单的情况：

1. 当三堆石子只有一堆还有石子，其余两堆都被拿光了，如`(0, 0, c)`，则  
1）如果此时`c=1`，则取子玩家就输了；  
2）如果此时`c>1`，则取子玩家只需取走`c-1`个石子就能取得胜利。

2. 当三堆石子有两堆还有石子，另一堆被拿光了，如`(0, b, c)`，则  
1）如果`b=c`，即当前状态为`(0, b, b)`，则取子玩家输，因为取子玩家取子后者必有取胜策略；  
2）如果`b!=c`，则当前取子有必胜策略，即只要把多的那堆取到数目跟另一堆一样多，使其转化为`(0, b, b)`状态。

3. 当三堆石子的数目都大于`0`，即`(a, b, c)`，其中`a>0`, `b>0`, `c>0`，则  
1）如果其中两堆石子的数目相同，即如出现`(a, b, b)`的情况，则取子者有必胜的策略，只需从第一堆拿去`a`个石子使其状态转成`(0, b, b)`的情况即可；  
2）如果`a!=b!=c`呢？实际上这也是最普通的情况，也是我们讨论的重点。其实，如果我们有稍微遍例一下，我们会发现一些状态是取子玩家必输的，比如`(1, 2, 3)`，`(1, 4, 5)`，`(2, 4, 6)`等等。

为了方便起见，我们定义**P-position**和**N-position**。其中P代表Previous，N代表Next。直观地说，如果双方都按最佳策略进行游戏，我们把一个先手取子必胜的状态称为N状态，把后手取子必胜的状态称为P状态。

那么，根据上面的定义，我们的取胜策略应该是尽量使对手在P状态下取子，也尽量避免自己“陷入”P状态，所以P状态是关键。

###结论

上面是我最初思考这个问题的一个思路，不过，前人已经很好的解决了Nim取子问题了，直接给出结论：

> (Bouton's Theorem)：对于一个Nim游戏的局面(a1,a2,...,an)，它是P-position当且仅当a1^a2^...^an=0，其中^表示异或(xor)运算。

哇！一个简单的异或运算解决了所有问题，是不是有种神奇的感觉？没错，数学就是这么的神奇，有兴趣的话你可以去查查相关的证明。结论还隐含了两个重要的引论（姑且称为引论）：

> 1. 无法从一个P状态进入另一个P状态；
> 2. 任意一个N状态都有策略使其进入另一个P状态；

太可怕了有木有，也就是说如果你掌握了取胜策略，且由你选择先手或后手，则你必胜。所以从某种意义上来说，这不是一个公平的游戏，如果对方不会玩的话。而且这个游戏的玩法简单，道具也没什么要求，一张纸一支笔，或者一堆石头，一包牙签，就都可以玩，推荐在同学聚会或无聊的时候玩，还可以虐虐菜什么的，哈哈。（Ps：当年我们就是被那个老教授给虐的。）

###附录

下面以每堆数目10为上限，给出P状态，只要记住这些P状态，再根据取胜策略（尽量使对手在P状态下取子，也尽量避免自己“陷入”P状态），那就能无往不利了！(下面只给出`a!=b!=c`的状态，对于一堆为空或两堆为空的状态比较简单，这里就不给出了。)

{% highlight c %}
(1, 2, 3)
(1, 4, 5)
(2, 4, 6)
(3, 5, 6)
(3, 4, 7)
(2, 5, 7)
(1, 6, 7)
(1, 8, 9)
(2, 8, 10)
(3, 9, 10)
{% endhighlight %}

下面是C的简单源码：

{% highlight c %}
/*To List Out All The P-positions*/
#include <stdio.h>
#define N 0;
#define P 1;
#define MAX_STONES 10;	//the maximum of each pile's stones

int main()
{
    int mat = MAX_STONES;
    mat++;
    int d[mat][mat][mat];
    int i, j, k;

    for(i = 0; i < mat; i++) {
        for(j = 0; j <= i; j++) {
            for(k = 0; k <= j; k++) {
                    if((i ^ j ^ k) == 0) {
                        d[i][j][k] = P;
                        printf("(%d, %d, %d)\n", k, j, i);
                    }else{
                        d[i][j][k] = N;
                    }
            }
        }
    }

    return 1;
}
{% endhighlight %}

更多：

[Nim游戏](http://baike.baidu.com/view/1101962.htm)  
[二进制法解“抓三堆”问题](http://zhan.renren.com/shuxuexiehui?gid=3602888498002367596&from=post&checked=true)  
[Nim游戏博弈(收集完全版)](http://www.cnblogs.com/exponent/articles/2141477.html)  
[一道面试题（Nim取子游戏）——如何将数学思维应用到编程中](http://www.cnblogs.com/HCOONa/archive/2012/04/24/game-of-nim1.html)  









